{"id":"CQsF","dependencies":[{"name":"D:\\es6Demo\\.babelrc","includedInParent":true,"mtime":1540218912012},{"name":"D:\\es6Demo\\package.json","includedInParent":true,"mtime":1540443383099}],"generated":{"js":"\"use strict\";","map":{"mappings":[{"source":"dist/index.js","original":{"line":69,"column":0},"generated":{"line":1,"column":0}}],"sources":{"dist/index.js":"// let a=1;\n// console.log(a);\n// let b=3;\n// let c=6;\n// console.log(c);\n\n// var varible//变量；\n// var a=\"jiegiser\";\n\n// //console.log(a);\n// window.onload=function(){\n//     console.log(a);\n// };//页面全部加载之后执行\n// 2018.10.23\n//var a = \"jiegiser\";\n// {\n//     let a = \"jiegiser 局部\";\n// }\n// console.log(a); //可以访问到a，a全局变量({里面let声明的访问不到})\n\n// // 方法体中，使用的变量一般用let声明，不污染全局变量；\n\n// const b=\"jiegiser\";\n// // var b='ddd';常量是不可以改变\n// console.log(b);\n\n\n// 2018.10.24\n// 定义变量\n// let [a,b,c]=[0,1,2];\n// console.log(a);\n// console.log(b);\n// console.log(c);\n\n// 比如我们需要定义数组\n// let [a,[b,c],d]=[0,[1,2],3];\n// console.log(a);\n// console.log(b);\n// console.log(c);\n// console.log(d);\n\n// 定义变量的时候需要定义默认值\n// let [foo=\"true\"]=[];\n// console.log(foo);\n\n\n// undefined与null的区别,undefined是代表没有赋值，就取默认值，null是有值，就读，\n// let [a,b=\"jiegiser\"]=['gis',undefined];\n// console.log(a+b);\n// let [c,d=\"jiegiser\"]=['gis',null];\n// console.log(c+d);\n\n// 对象的属性结构是没有位置关系的，前面的数组进行结构的时候，根位置有关，对象我们在后面使用了key值进行了赋值\n// let {a,b}={a:'jiegiser',b:'杰'};\n// console.log(a+b);\n\n// 下面是一个小坑，，就是先赋值了，之后需要结构，必须在解构的外面加一个小括号；\n// let foo;\n// ({foo}={foo:\"jiegiser\"});\n\n// \n// const [a,b,c,d,e,f]='jiegis';\n// console.log(a);\n// console.log(b);\n// console.log(c);\n// console.log(d);\n// console.log(e);\n// console.log(f);\n\"use strict\";\n"},"lineCount":null}},"hash":"fb474b86e75838b1461a6a21e5c383c0","cacheData":{"env":{}}}